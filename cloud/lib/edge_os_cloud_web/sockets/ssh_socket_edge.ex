defmodule EdgeOsCloud.Sockets.SSHSocketEdge do
  @moduledoc """
  Websocket handler for Edge devices bridge the ssh sessions.
  For the comments/docs of the websocket related functions,
  please refer to the module EdgeOsCloud.Sockets.ETSocket.

  Here comes a sample connection from edge:
  wss://edgeos.sailoi.com/ssh?ssh_token=<ssh_token>&id_hash=<edge id hash generated by edge>
  """
  require Logger
  @behaviour :cowboy_websocket

  def get_pid(session_id) do
    String.to_atom("edge_session_id_#{session_id}_to_edge")
  end

  @impl :cowboy_websocket
  def init(req, opts) do
    Logger.debug("init with #{inspect req} and #{inspect opts}")
    query = URI.query_decoder(req.qs) |> Enum.to_list() |> Map.new(fn {k, v} -> {k, v} end)

    edge = EdgeOsCloud.Device.get_edge_with_uuid!(query["uuid"])
    session = EdgeOsCloud.HashIdHelper.decode(query["ssh_token"], edge.salt)
    		  |> EdgeOsCloud.Device.get_edge_session!()

    if session.edge_id == edge.id do
      Logger.info("edge #{edge.id} connected for ssh bridging")
      EdgeOsCloud.Device.update_edge_session(session, 
        %{
   	      stage: EdgeOsCloud.Device.EdgeSessionStage.edge_connected,
        })

      {:ok, _} = Registry.register(EdgeOsCloud.SSHRegistry, get_pid(session.id), session.id)
      {:cowboy_websocket, req, %{edge: edge, session: session, got_message: false, sent_message: false}}
    else
      # don't know what this connection is for. closing it
      raise "edge #{inspect edge} and session #{inspect session} do not match"
    end
  end

  @impl :cowboy_websocket
  def websocket_init(state) do
    Logger.debug("websocket_init with #{inspect state}")
    {[], state}
  end

  @impl :cowboy_websocket
  def websocket_handle(frame, state)

  def websocket_handle(:ping, state) do
    Logger.debug("getting a ping from client, ponging back")
    {[:pong], state}
  end

  def websocket_handle({:text, message}, state) do
    Logger.debug("getting message #{message} from client")
    %{session: session, got_message: got_message} = state

    state = if not got_message do
      EdgeOsCloud.Device.update_edge_session(session, 
        %{
   	      stage: EdgeOsCloud.Device.EdgeSessionStage.ssh_data_get,
        })
      Map.put(state, :got_message, true)
    else
      state
    end

    {[{:text, message}], state}
  end

  @impl :cowboy_websocket
  def websocket_info(info, state)

  def websocket_info(:stop, state) do
    Logger.debug("closing websocket with #{inspect state}")
    {:stop, state}
  end

  def websocket_info(info, state) do
    Logger.debug("websocket_info with #{inspect info} and #{inspect state}")
    %{session: session, sent_message: sent_message} = state

    state = if not sent_message do
      EdgeOsCloud.Device.update_edge_session(session, 
        %{
   	      stage: EdgeOsCloud.Device.EdgeSessionStage.ssh_data_sent,
        })
      Map.put(state, :sent_message, true)
    else
      state
    end

    {[], state}
  end

  @impl :cowboy_websocket
  def terminate(reason, req, state)

  def terminate(reason, req, state) do
    Logger.debug("terminating websocket with #{inspect reason}: #{inspect req}: #{inspect state}")
    %{session: session} = state
    EdgeOsCloud.Device.update_edge_session(session, 
      %{
   	    stage: EdgeOsCloud.Device.EdgeSessionStage.edge_disconnected,
   	    reason: "#{inspect reason}"
      })
    :ok
  end
end
